<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NICE.TRADING</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #ffffff;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   system-ui, -system-ui, "Segoe UI", sans-serif;
    }

    body {
      position: relative;
      color: #111111;
    }

    /* Contenedor principal */
    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #ffffff;
    }

    /* Título superior izquierda (similar a la captura) */
    .brand {
      position: absolute;
      top: 32px;
      left: 40px;
      letter-spacing: 0.35em;
      font-size: 14px;
      text-transform: uppercase;
      font-weight: 500;
      z-index: 2;
      color: #111111;
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    /* Canvas de líneas */
    #linesCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: #ffffff;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="brand">N I C E . T R A D I N G</div>
    <canvas id="linesCanvas"></canvas>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("linesCanvas");
      const ctx = canvas.getContext("2d");

      let width = window.innerWidth;
      let height = window.innerHeight;

      // Parámetros visuales para que se parezca a la captura
      const NUM_LINES = 26;          // Número de líneas horizontales
      const LINE_COLOR = "#d3d3d3";  // Gris claro para las líneas
      const LINE_WIDTH = 0.8;        // Grosor de línea
      const NOISE_SCALE_X = 0.0022;  // Escala ruido eje X
      const NOISE_SCALE_T = 0.0004;  // Escala ruido tiempo
      const AMPLITUDE = 55;          // Amplitud vertical del relieve
      const LINE_SPACING = 26;       // Distancia vertical entre líneas
      const POINT_DENSITY = 1.2;     // Distancia entre puntos a lo largo de X

      // Para dar personalidad a cada línea
      const lineOffsets = [];

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      window.addEventListener("resize", () => {
        resize();
        updateBaseY();
      });

      resize();

      // ------------ Ruido 2D simple (tipo value noise) ------------

      function hash(x, y) {
        const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
        return s - Math.floor(s);
      }

      function noise2D(x, y) {
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        const fx = x - ix;
        const fy = y - iy;

        const a = hash(ix, iy);
        const b = hash(ix + 1, iy);
        const c = hash(ix, iy + 1);
        const d = hash(ix + 1, iy + 1);

        const u = fx * fx * (3 - 2 * fx);
        const v = fy * fy * (3 - 2 * fy);

        return (
          a * (1 - u) * (1 - v) +
          b * u * (1 - v) +
          c * (1 - u) * v +
          d * u * v
        );
      }

      // Inicializar offsets de cada línea
      for (let i = 0; i < NUM_LINES; i++) {
        lineOffsets.push({
          baseY: (height * 0.5) + (i - NUM_LINES / 2) * LINE_SPACING,
          noiseOffsetX: Math.random() * 1000,
          noiseOffsetT: Math.random() * 1000,
        });
      }

      function updateBaseY() {
        for (let i = 0; i < NUM_LINES; i++) {
          lineOffsets[i].baseY =
            height * 0.5 + (i - NUM_LINES / 2) * LINE_SPACING;
        }
      }

      // -------------------- Bucle de animación --------------------

      let lastTime = performance.now();

      function draw(timestamp) {
        const delta = timestamp - lastTime;
        lastTime = timestamp;

        ctx.clearRect(0, 0, width, height);

        ctx.lineWidth = LINE_WIDTH;
        ctx.strokeStyle = LINE_COLOR;

        const t = timestamp; // ms para el ruido

        for (let i = 0; i < NUM_LINES; i++) {
          const { baseY, noiseOffsetX, noiseOffsetT } = lineOffsets[i];

          ctx.beginPath();

          const step = POINT_DENSITY;
          let firstPoint = true;

          // hacemos la línea un poco más ancha que la pantalla para evitar cortes en los bordes
          for (let x = -40; x <= width + 40; x += step) {
            const nx = (x + noiseOffsetX) * NOISE_SCALE_X;
            const nt = (t * NOISE_SCALE_T) + noiseOffsetT;

            const n = noise2D(nx, nt) - 0.5; // rango [-0.5, 0.5]
            const y = baseY + n * AMPLITUDE;

            if (firstPoint) {
              ctx.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx.lineTo(x, y);
            }
          }

          ctx.stroke();
        }

        // Sin barra vertical en el centro: NO dibujamos nada ahí.

        requestAnimationFrame(draw);
      }

      requestAnimationFrame(draw);
    })();
  </script>
</body>
</html>
